- プロジェクトで引き回す型をEffにするメリット

Eff の話　以外に
業務例外・システム例外 を含む型の扱い方のメリデメ一覧となっていて良き

・Future[A]
・Future[Try[A]]
・Future[EIther[E,A]]
・Either[Future,E,A]

- Future の代わりに Task が使われることもある
  Task とは？  monix.Task とScalaz.Task がある

・Eff[E,A]



----
・Future[A]
  まずは使い方 (cup本参照)
  - ポーリング(処理が完了したかどうかを調べる)のために
    isCompleted と value がある

    isCompleted: Boolean
      処理が完了していないならfalse, 完了したら true を返す

    value: Option[Try]
      処理が完了していないならNone, 完了したら Some(Try) を返す

    ※ Try 型
      Success と Failure があり、これでエラーハンドリングをする

      通常のtry-catch では
      非同期処理の場合計算を始めたスレッド != 例外を投げたスレッド となることがあり
      元のスレッドがcatch節を処理できない


エラーハンドリングが荒い
=> Throwable で業務例外を作る // Javaっぽい感じ
     class UserNotFoundExeption extends MyException 的な
     Throwableを扱うから型安全でない？


・vs Option  Throwable を持つぶん Noneよりは情報がある
・vs Either  Either[Throwable, T] と同様

コールバック : 関数を渡すこと
  Future に関数  Thread.sleep ; 21 * 23 ; をわたす　みたいな

https://docs.scala-lang.org/ja/overviews/core/futures.html


Futureでのエラーハンドリングはこんな感じ？


Try[T] は SUccess[T] または Failure[]

問題 セマフォ の制御？ ができない [要検証]




